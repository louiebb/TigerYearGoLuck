# 前端底层原理宝典

## 自动柯里化函数

* 特点
    1. 返回新函数N
    2. 函数N调参多样化（执行返回函数）
    3. 闭包记录原函数，递归函数和已知参数
    4. 满足条件执行原函数（已知参数长度大于等原函数参长度）
* 实现代码

    ```js
        function sum(x, y, z){
            return x + y + z;
        }

        // 实现目标
        let carry = autoCarry(sum)
        console.log(carry(1,2,3))
        console.log(carry(1,2)(3))
        console.log(carry(1)(2)(3))

        function autoCarry(fn){
            function _carry(...arg){
                // 当已知参数>=原函数参数长度
                if(arg.length >= fn.length){
                    // 执行原函数
                    return fn.apply(this, arg)
                } else { // 不满足，则返回函数递归调用_carry
                    return function(...args){
                        // 拼接整合当前传入参数和闭包记录的已知参数，得到新的已知参数
                        let arr = [...arg,...args]
                        return _carry.apply(this, arr)
                    }
                }
            }
            return _carry
        }
    ```

## Promise实现

* 特点
  1. 拥有三种状态
     * pending (待定)
     * fulfilled (已实现，对应resolve)
     * rejected (已拒绝，对应reject)
  2. 状态不可撤回
  3. 链式调用并返回新的new Promise
  4. 通过resolve和reject进行返回值
  5. 传入的回调立即执行
  6. then方法可多次调用
* 实现代码

```js
    let PENDING_STATE = 'pending'
let REJECTED_STATE = 'rejected'
let FULFILLED_STATE = 'fulfill'
function execFunctionWithCatchError(execFn, value, resolve, reject) {
    try {
        let result = execFn(value)
        resolve(result)
    } catch (err) {
        reject(err)
    }
}

class _Promise {
    constructor(execFn) {
        // 当前状态
        this._state = PENDING_STATE
        // 成功值
        this._value = undefined
        // 失败值
        this._reason = undefined
        this.onFulfilledFns = []
        this.onRejectedFns = []
        // 传出的函数
        const resolve = (value) => {
            if (this._state === PENDING_STATE) {
                // 压入微任务队列
                queueMicrotask(() => {
                    if (this._state !== PENDING_STATE) return
                    this._state = FULFILLED_STATE
                    this._value = value
                    console.log(value, 777);
                    // then 传入的函数队列
                    this.onFulfilledFns.forEach((fn) => {
                        // then 传入的函数 把值传出
                        fn(this._value)
                    })
                })
            }
        }
        // 传出的函数
        const reject = (reason) => {
            if (this._state === PENDING_STATE) {
                // 压入微任务队列
                queueMicrotask(() => {
                    if (this._state !== PENDING_STATE) return
                    this._state = REJECTED_STATE
                    this._reason = reason
                    // then 传入的函数队列
                    this.onRejectedFns.forEach((fn) => {
                        // then 传入的函数 把值传出
                        fn(this._reason)
                    })
                })
            }
        }
        try {
            // 传入的函数
            execFn(resolve, reject)
        } catch (err){
            reject(err)
        }
    }
    then(onResolve, onReject) {
        return new _Promise((resolve, reject) => {
            // 1.如果在then调用的时候, 状态已经确定下来
            if (this._state === FULFILLED_STATE && onResolve) {
                // onResolve(this._value)
                execFunctionWithCatchError(onResolve, this._value, resolve, reject)
            }
            if (this._state === REJECTED_STATE && onReject) {
                // onReject(this._reason)
                execFunctionWithCatchError(onReject, this._reason, resolve, reject)
            }

            // 2.pending中的
            // 实例可多次调用then
            if (this._state === PENDING_STATE) {
                // this.onFulfilledFns.push(onResolve)
                // this.onRejectedFns.push(onReject)
                this.onFulfilledFns.push(()=>{
                    //  this._value 指向上一个promise 的值
                    console.log(this._value, 999);
                    execFunctionWithCatchError(onResolve, this._value, resolve, reject)
                })
                this.onRejectedFns.push(()=>{
                    execFunctionWithCatchError(onReject, this._reason, resolve, reject)
                })
            }
        })
    }
}
function execFnc(resolve, reject){
 // resolve 和 reject为 执行传入的函数
 // 111 为传出的值
 resolve(111)
 // reject(222)
}
// execFnc 为传入函数
let promise = new _Promise(execFnc)

promise.then(
        (res) => {
            // 函数队列传出值 res -> 111
            console.log(1, res)
            return 110
        },
        (err) => {
            console.log(4, err)
        }
    ).then(
        (res) => {
            // 函数队列传出值 res
            console.log(2, res)
        },
        (err) => {
            console.log(5, err)
        }
    )

// setTimeout(()=>{
//     promise.then((res)=>{
//         console.log(2,res);
//     },(err)=>{
//         console.log(5,err);
//     })
// },2000)

// promise.then((res)=>{
//     console.log(2,res);
// },(err)=>{
//     console.log(5,err);
// })

// promise.then((res)=>{
//     console.log(3,res);
// },(err)=>{
//     console.log(6,err);
// })

```